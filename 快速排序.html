<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>快速排序</title>
</head>
<body>
	<ul>
		<li>分而治之思想</li>
		<li>处理大数据最快的排序算法之一</li>
		<li>快速排序的最坏运行情况是O(n^2)，比如说顺序数列的快排。但它的平摊期望时间是O(nlogn),且O(nlogn)记号中的隐含的常数因子很小，比复杂度稳定等于O(nlogn)的归并排序要小很多。所以，对绝大多数顺序较弱的随机数列而言，快速片排序总是优于归并排序。</li>
	</ul>
	<img src="img/kuaisu.gif">
	<script type="text/javascript">
		// var arr = [32,3,1,13,43,21,64];
		// function quickSort(arr){
		// 	// console.log("haha");
		// 	var len = arr.length;
		// 	var partitionIndex;
		// 	var left=typeof left !='number'?0:left;
		// 	var right=typeof right !='number'?len-1:right;

		// 	if(left<right){
		// 		partitionIndex=partition(arr,left,right);
		// 		quickSort(arr,left,partitionIndex-1);
		// 		quickSort(arr,partitionIndex+1,right);
		// 	}
		// 	return arr;
		// }
		// // 分区操作
		// function partition(arr,left,right){
		// 	var pivot=left; //设置基准数pivot
		// 	var index=pivot+1;
		// 	for(var i=index;i<=right;i++){
		// 		if (arr[i]<arr[pivot]) {
		// 			swap(arr,i,index);
		// 			index++;
		// 		}
		// 	}
		// 	swap(arr,pivot,index-1);
		// 	return index-1;
		// }
		// function swap(arr,i,j){
		// 	var temp=arr[i];
		// 	arr[i]=arr[j];
		// 	arr[j]=temp;
		// }
		// console.log(quickSort(arr));


		var quickSort = function(arr) {
		    console.time('快速排序耗时');
		　　if (arr.length <= 1) { return arr; }
		　　var pivotIndex = Math.floor(arr.length / 2);
		　　var pivot = arr.splice(pivotIndex, 1)[0];
		　　var left = [];
		　　var right = [];
		　　for (var i = 0; i < arr.length; i++){
		　　　　if (arr[i] < pivot) {
		　　　　　　left.push(arr[i]);
		　　　　} else {
		　　　　　　right.push(arr[i]);
		　　　　}
		　　}
		console.timeEnd('快速排序耗时');
		　　return quickSort(left).concat([pivot], quickSort(right));
		};

		var arr = [32,3,1,13,43,21,64];
		console.log(quickSort(arr));
	</script>
</body>
</html>